---
title: Advent of Code 2021 - Days 5-12
author: Aron
tags: [advent-of-code, javascript]
---

I spent _hours_ on day 5 building complex things that didn't work. That left me
in a mood to hack and golf more, idealize less. Anyway, here's the past week's
worth:

## Day 5

```typescript
interface Point {
  x: number
  y: number
}

interface Segment {
  a: Point
  b: Point
}

export const pointsOf = (g: Segment): Point[] => {
  let {a, b} = g
  const dx = b.x < a.x ? -1 : b.x > a.x ? 1 : 0
  const dy = b.y < a.y ? -1 : b.y > a.y ? 1 : 0
  const points = []
  for (let x = a.x, y = a.y; x !== b.x || y !== b.y; x += dx, y += dy) {
    points.push({x, y})
  }
  points.push(b)
  return points
}

export const d5 = ({
  input = inputs.d5,
  part,
}: {
  input?: string
  part: 'a' | 'b'
}) => {
  const horiz = ({a, b}: Segment) => a.y === b.y
  const vert = ({a, b}: Segment) => a.x === b.x
  const lines = ranks(ints(input), 4)
    .map(([ax, ay, bx, by]) => ({a: {x: ax, y: ay}, b: {x: bx, y: by}}))
    .filter(g => part === 'b' || horiz(g) || vert(g))
  const seen = reduce(
    lines,
    (seen, line) =>
      reduce(
        pointsOf(line).map(({x, y}) => `${x},${y}`),
        (seen, p) => ((seen[p] = (seen[p] || 0) + 1), seen),
        seen,
      ),
    {},
  )
  return Object.values(seen).filter(n => n > 1).length
}
```

Day 5a sample:

<Advent day={5} part="a" input={`
0,9 -> 5,9
8,0 -> 0,8
9,4 -> 3,4
2,2 -> 2,1
7,0 -> 7,4
6,4 -> 2,0
0,9 -> 2,9
3,4 -> 1,4
0,0 -> 8,8
5,5 -> 8,2
`} debug />

Day 5a mine:

<Advent day={5} part="a" debug />

Day 5b sample:

<Advent day={5} part="b" input={`
0,9 -> 5,9
8,0 -> 0,8
9,4 -> 3,4
2,2 -> 2,1
7,0 -> 7,4
6,4 -> 2,0
0,9 -> 2,9
3,4 -> 1,4
0,0 -> 8,8
5,5 -> 8,2
`} debug />

Day 5b mine:

<Advent day={5} part="b" debug />

## Day 6

```typescript
export const d6 = ({
  input = inputs.d6,
  part,
}: {
  input?: string
  part: 'a' | 'b'
}) => {
  let state = reduce(
    ints(input),
    (state, i) => (state[i]++, state),
    Array(9).fill(0),
  )
  const days = part === 'a' ? 80 : 256
  for (let day = 0; day < days; day++) {
    state[9] = state[0]
    state[7] += state[0]
    state.shift()
  }
  return sum(state)
}
```

Day 6a sample:

<Advent day={6} part="a" input="3,4,3,1,2" debug />

Day 6a mine:

<Advent day={6} part="a" debug />

Day 6b sample:

<Advent day={6} part="b" input="3,4,3,1,2" debug />

Day 6b mine:

<Advent day={6} part="b" debug />

## Day 7a

```typescript
export const d7a = ({input = inputs.d7}: {input?: string}) => {
  const ns = ints(input)
  const costs = R.range(min(ns), max(ns)).map(pos =>
    sum(ns.map(n => Math.abs(n - pos))),
  )
  return min(costs)
}
```

Day 7a sample:

<Advent day={7} part="a" input="16,1,2,0,4,2,7,1,2,14" debug />

Day 7a mine:

<Advent day={7} part="a" debug />

## Day 7b

```typescript
export const d7b = ({input = inputs.d7}: {input?: string}) => {
  const ns = ints(input)
  // cost-per-distance lookup table
  const {cpd} = R.range(0, max(ns) - min(ns) + 1).reduce(
    ({cpd, rate}, d) => {
      cpd[d + 1] = cpd[d] + rate
      return {cpd, rate: rate + 1}
    },
    {cpd: [0], rate: 0},
  )
  cpd.shift() // avoids needing (cpd[d] || 0) in the reduction
  const costs = R.range(min(ns), max(ns)).map(pos =>
    sum(ns.map(n => cpd[Math.abs(n - pos)])),
  )
  return min(costs)
}
```

Day 7b sample:

<Advent day={7} part="b" input="16,1,2,0,4,2,7,1,2,14" debug />

Day 7b mine:

<Advent day={7} part="b" debug />

## Day 8a

```typescript
export const d8a = ({input = inputs.d8}: {input?: string}) => {
  const digs = ranks(clean(input).split(/\W+/), 14).flatMap(xs => xs.slice(10))
  return sum(digs.map(dig => Number([2, 3, 4, 7].includes(dig.length))))
}
```

Day 8a short:

<Advent day={8} part="a" input={`
acedgfb cdfbe gcdfa fbcad dab cefabd cdfgeb eafb cagedb ab | cdfeb fcadb cdfeb cdbaf
`} debug />

Day 8a long:

<Advent day={8} part="a" input={`
be cfbegad cbdgef fgaecd cgeb fdcge agebfd fecdb fabcd edb | fdgacbe cefdb cefbgd gcbe
edbfga begcd cbg gc gcadebf fbgde acbgfd abcde gfcbed gfec | fcgedb cgb dgebacf gc
fgaebd cg bdaec gdafb agbcfd gdcbef bgcad gfac gcb cdgabef | cg cg fdcagb cbg
fbegcd cbd adcefb dageb afcb bc aefdc ecdab fgdeca fcdbega | efabcd cedba gadfec cb
aecbfdg fbg gf bafeg dbefa fcge gcbea fcaegb dgceab fcbdga | gecf egdcabf bgf bfgea
fgeab ca afcebg bdacfeg cfaedg gcfdb baec bfadeg bafgc acf | gebdcfa ecba ca fadegcb
dbcfg fgd bdegcaf fgec aegbdf ecdfab fbedc dacgb gdcebf gf | cefg dcbef fcge gbcadfe
bdfegc cbegaf gecbf dfcage bdacg ed bedf ced adcbefg gebcd | ed bcgafe cdgba cbgef
egadfb cdbfeg cegd fecab cgb gbdefca cg fgcdab egfdb bfceg | gbdfcae bgc cg cgb
gcafb gcf dcaebfg ecagb gf abcdeg gaef cafbge fdbac fegbdc | fgae cfgab fg bagce
`} debug />

Day 8a mine:

<Advent day={8} part="a" debug />

## Day 8b

```typescript
export const d8b = ({input = inputs.d8}: {input?: string}) => {
  const eight = new Set('abcdefg')
  const signals = ranks(clean(input).split(/\W+/), 14).map(xs => ({
    sigs: xs.slice(0, 10).map(x => new Set(x)),
    one: new Set(xs.find(x => x.length === 2)),
    four: new Set(xs.find(x => x.length === 4)),
    seven: new Set(xs.find(x => x.length === 3)),
    ins: xs.slice(10).map(x => new Set(x)),
  }))
  return sum(
    signals.map(({one, four, seven, sigs, ins}) => {
      const nine = sole(sigs.filter(x => x.size === 6 && isSuperset(x, four)))
      const e = sole(difference(eight, nine))
      const two = sole(sigs.filter(x => x.size === 5 && x.has(e)))
      const f = sole(difference(one, two))
      const c = sole(difference(one, f))
      const three = sole(
        sigs.filter(x => x.size === 5 && x !== two && x.has(c)),
      )
      const five = sole(
        sigs.filter(x => x.size === 5 && x !== two && x !== three),
      )
      const zero = sole(
        sigs.filter(x => x.size === 6 && x !== nine && x.has(c)),
      )
      const six = sole(
        sigs.filter(x => x.size === 6 && x !== nine && x !== zero),
      )
      const numbers = [
        zero,
        one,
        two,
        three,
        four,
        five,
        six,
        seven,
        eight,
        nine,
      ]
      const outs = ins.map(i => numbers.findIndex(n => equals(i, n)))
      return parseInt(outs.join(''))
    }),
  )
}

function isSuperset(set: Set<any>, subset: Set<any>) {
  for (let x of subset) {
    if (!set.has(x)) {
      return false
    }
  }
  return true
}

function difference<T = any>(a: Set<T>, b: Set<any> | any[] | string): Set<T> {
  let d = new Set(a)
  for (let x of b) {
    d.delete(x as unknown as T)
  }
  return d
}

function sole<T = any>(xs: Set<T> | Array<T>): T {
  if (Array.isArray(xs)) {
    if (xs.length !== 1) {
      throw new TypeError(
        `can't determine sole member of array length ${xs.length}`,
      )
    }
    return xs[0]
  }
  if (xs.size !== 1) {
    throw new TypeError(`can't determine sole member of set size ${xs.size}`)
  }
  for (let member of xs) {
    return member
  }
}

function equals(a: Set<any>, b: Set<any>) {
  return a.size === b.size && difference(a, b).size === 0
}
```

Day 8b short:

<Advent day={8} part="b" input={`
acedgfb cdfbe gcdfa fbcad dab cefabd cdfgeb eafb cagedb ab | cdfeb fcadb cdfeb cdbaf
`} debug />

Day 8b long:

<Advent day={8} part="b" input={`
be cfbegad cbdgef fgaecd cgeb fdcge agebfd fecdb fabcd edb | fdgacbe cefdb cefbgd gcbe
edbfga begcd cbg gc gcadebf fbgde acbgfd abcde gfcbed gfec | fcgedb cgb dgebacf gc
fgaebd cg bdaec gdafb agbcfd gdcbef bgcad gfac gcb cdgabef | cg cg fdcagb cbg
fbegcd cbd adcefb dageb afcb bc aefdc ecdab fgdeca fcdbega | efabcd cedba gadfec cb
aecbfdg fbg gf bafeg dbefa fcge gcbea fcaegb dgceab fcbdga | gecf egdcabf bgf bfgea
fgeab ca afcebg bdacfeg cfaedg gcfdb baec bfadeg bafgc acf | gebdcfa ecba ca fadegcb
dbcfg fgd bdegcaf fgec aegbdf ecdfab fbedc dacgb gdcebf gf | cefg dcbef fcge gbcadfe
bdfegc cbegaf gecbf dfcage bdacg ed bedf ced adcbefg gebcd | ed bcgafe cdgba cbgef
egadfb cdbfeg cegd fecab cgb gbdefca cg fgcdab egfdb bfceg | gbdfcae bgc cg cgb
gcafb gcf dcaebfg ecagb gf abcdeg gaef cafbge fdbac fegbdc | fgae cfgab fg bagce
`} debug />

Day 8b mine:

<Advent day={8} part="b" debug />

## Day 9a

Feeling a bit more idealistic, I guess, wrote a lib function to reduce over
a two-dimensional grid:

```typescript
interface GridReduce {
  <T = any, R = any>(grid: T[][], fn: (r: R, v: T) => R, init: R): R
  indexed: <T = any, R = any>(
    grid: T[][],
    fn: (r: R, v: T, p: Point) => R,
    init: R,
  ) => R
}

const gridReduce: GridReduce = (grid, fn, init) =>
  reduce(grid, (r, vs) => reduce(vs, (r, v) => fn(r, v), r), init)

gridReduce.indexed = (grid, fn, init) =>
  reduce.indexed(
    grid,
    (r, vs, y) => reduce.indexed(vs, (r, v, x) => fn(r, v, {x, y}), r),
    init,
  )
```

Here's my solution for day 9a using `gridReduce`:

```typescript
export const d9a = ({input = inputs.d9}: {input?: string}) => {
  const width = clean(input).indexOf('\n')
  const depths = ranks(Array.from(input.replace(/\D/g, '')).map(parse10), width)
  const deltas = [-1, 1].flatMap(d => [
    {dx: d, dy: 0},
    {dx: 0, dy: d},
  ])
  const nearby = ({x, y}: Point): Point[] =>
    R.pipe(
      deltas,
      R.map(({dx, dy}) => ({x: x + dx, y: y + dy})),
      R.filter(({x, y}) => x >= 0 && x < width && y >= 0 && y < depths.length),
    )
  const depthAt = ({x, y}: Point) => depths[y][x]
  return gridReduce.indexed(
    depths,
    (risk, d, p) =>
      nearby(p)
        .map(depthAt)
        .every(s => s > d)
        ? risk + d + 1
        : risk,
    0,
  )
}
```

Day 9a sample:

<Advent day={9} part="a" debug input={`
2199943210
3987894921
9856789892
8767896789
9899965678
`} />

Day 9a mine:

<Advent day={9} part="a" debug />

## Day 9b

```typescript
const setAdd = <T = any>(set: Set<T>, x: T) => {
  const sizeBefore = set.size
  set.add(x)
  return set.size > sizeBefore
}

export const d9b = ({input = inputs.d9}: {input?: string}) => {
  const width = clean(input).indexOf('\n')
  const depths = ranks(Array.from(input.replace(/\D/g, '')).map(parse10), width)
  const deltas = [-1, 1].flatMap(d => [
    {dx: d, dy: 0},
    {dx: 0, dy: d},
  ])
  const nearby = (
    {x, y}: Point,
    {w, h}: {w: number; h: number} = {w: width, h: depths.length},
  ): Point[] =>
    R.pipe(
      deltas,
      R.map(({dx, dy}) => ({x: x + dx, y: y + dy})),
      R.filter(({x, y}) => x >= 0 && x < w && y >= 0 && y < h),
    )
  const depthAt = ({x, y}: Point) => depths[y][x]
  const lows = gridReduce.indexed(
    depths,
    (lows, d, p) => (
      nearby(p)
        .map(depthAt)
        .every(s => s > d) && lows.push(p),
      lows
    ),
    [] as Point[],
  )
  const basinAt = (
    here: Point,
    found: Set<string> = new Set(),
  ): Set<string> => {
    for (const there of nearby(here)) {
      if (depthAt(there) < 9 && setAdd(found, `${there.x},${there.y}`)) {
        basinAt(there, found)
      }
    }
    return found
  }
  const basins = lows.map(low => basinAt(low))
  return R.pipe(
    basins.map(b => b.size).sort((a, b) => b - a),
    R.take(3),
    mult,
  )
}
```

Day 9b sample:

<Advent day={9} part="b" debug input={`
2199943210
3987894921
9856789892
8767896789
9899965678
`} />

Day 9b mine:

<Advent day={9} part="b" debug />

## Day 10a

```typescript
export const d10a = ({input = inputs.d10}: {input?: string}) => {
  const lines = clean(input).split(/\n/)
  const pairs = {'(': ')', '[': ']', '{': '}', '<': '>'}
  const points = {')': 3, ']': 57, '}': 1197, '>': 25137}
  const lineScore = (line: string) =>
    reduce(
      Array.from(line),
      ([stack]: [string[], number], c) => {
        if (points[c]) {
          if (pairs[R.last(stack)] !== c) {
            return reduced([[], points[c]])
          }
          stack.pop()
        } else {
          stack.push(c)
        }
        return [stack, 0]
      },
      [[], 0],
    )[1]
  return sum(lines.map(lineScore))
}
```

Sample:

<Advent day={10} part="a" debug input={`
[({(<(())[]>[[{[]{<()<>>
[(()[<>])]({[<{<<[]>>(
{([(<[<>[]}>{[]{[(<()>
(((({<>}<{<{<>}{[]{[]
[[<[([]))<([[[[()]]]
[{[{(]{}}([{[{{{}}([]
{<[[]]>}<{[{[{[]{()[[[]
[<(<(<(<))><([]([]()
<{([([[(<>())]>(<<{{
<{([{}[<[[[<>{}]]]>[]]
`} />

Mine:

<Advent day={10} part="a" debug />

## Day 10b

```typescript
export const d10b = ({input = inputs.d10}: {input?: string}) => {
  const lines = clean(input).split(/\n/)
  const pairs = {'(': ')', '[': ']', '{': '}', '<': '>'}
  const points = {')': 1, ']': 2, '}': 3, '>': 4}
  const lineScore = (line: string) =>
    reduce.indexed(
      Array.from(line),
      ([stack]: [string[], number], c, i) => {
        if (points[c]) {
          if (pairs[R.last(stack)] !== c) {
            return reduced([[], 0])
          }
          stack.pop()
        } else {
          stack.push(c)
        }
        if (i === line.length - 1 && stack.length) {
          return [
            [],
            stack
              .reverse()
              .reduce((score, c) => 5 * score + points[pairs[c]], 0),
          ]
        }
        return [stack, 0]
      },
      [[], 0],
    )[1]
  const scores = lines.map(lineScore).filter(Boolean)
  return scores.sort((a, b) => a - b)[(scores.length + 1) / 2 - 1]
}
```

Sample:

<Advent day={10} part="b" debug input={`
[({(<(())[]>[[{[]{<()<>>
[(()[<>])]({[<{<<[]>>(
{([(<[<>[]}>{[]{[(<()>
(((({<>}<{<{<>}{[]{[]
[[<[([]))<([[[[()]]]
[{[{(]{}}([{[{{{}}([]
{<[[]]>}<{[{[{[]{()[[[]
[<(<(<(<))><([]([]()
<{([([[(<>())]>(<<{{
<{([{}[<[[[<>{}]]]>[]]
`} />

Mine:

<Advent day={10} part="b" debug />

## Day 11a

```typescript
const flash = (vs: number[], i: number) => {
  vs[i] = 0
  const x = i % 10
  const y = (i - x) / 10
  for (const dx of [-1, 0, 1]) {
    for (const dy of [-1, 0, 1]) {
      if (dx || dy) {
        const xx = x + dx
        const yy = y + dy
        if (xx >= 0 && xx < 10 && yy >= 0 && yy < 10) {
          const j = yy * 10 + xx
          vs[j] = vs[j] && vs[j] + 1
        }
      }
    }
  }
}

export const d11a = ({input = inputs.d11}: {input?: string}) => {
  const vs = Array.from(input.replace(/\D/g, '')).map(x => parseInt(x))
  let flashes = 0
  for (let step = 0; step < 100; step++) {
    vs.forEach((_, i) => vs[i]++)
    for (let fs = flashes; ; flashes = fs) {
      vs.forEach((v, i) => v > 9 && (flash(vs, i), fs++))
      if (fs === flashes) {
        break
      }
    }
  }
  return flashes
}
```

Sample:

<Advent day={11} part="a" debug input={`
5483143223
2745854711
5264556173
6141336146
6357385478
4167524645
2176841721
6882881134
4846848554
5283751526
`} />

Mine:

<Advent day={11} part="a" debug />

## Day 11b

```typescript
export const d11b = ({input = inputs.d11}: {input?: string}) => {
  const vs = Array.from(input.replace(/\D/g, '')).map(x => parseInt(x))
  for (let step = 1; ; step++) {
    vs.forEach((_, i) => vs[i]++)
    let flashes = 0
    for (let fs = flashes; ; flashes = fs) {
      vs.forEach((v, i) => v > 9 && (flash(vs, i), fs++))
      if (fs === flashes) {
        break
      }
    }
    if (flashes === vs.length) {
      return step
    }
  }
}
```

Sample:

<Advent day={11} part="b" debug input={`
5483143223
2745854711
5264556173
6141336146
6357385478
4167524645
2176841721
6882881134
4846848554
5283751526
`} />

Mine:

<Advent day={11} part="b" debug />

## Day 12a

```typescript
export const d12 = ({
  input = inputs.d12,
  pre,
  post,
}: {
  input?: string
  pre: (node: string) => boolean
  post: (node: string) => void
}) => {
  const graph = clean(input)
    .split(/\n/)
    .map(s => s.split('-'))
    .reduce((graph, [k, v]) => {
      if (v !== 'start') {
        graph[k] = graph[k] || []
        graph[k].push(v)
      }
      if (k !== 'start') {
        graph[v] = graph[v] || []
        graph[v].push(k)
      }
      return graph
    }, {})
  let n = 0
  const walk = (node: string) => {
    if (node === 'end') {
      n++
    } else {
      for (const next of graph[node]) {
        pre(next) && (walk(next), post(next))
      }
    }
  }
  walk('start')
  return n
}

export const d12a = props => {
  const sm = (s: string) => s.charCodeAt(0) >= 97
  const v = {}
  return d12({
    ...props,
    pre: (node: string) => (v[node] ? false : ((v[node] = sm(node)), true)),
    post: (node: string) => (v[node] = false),
  })
}
```

Example:

<Advent day={12} part="a" debug input={`
start-A
start-b
A-c
A-b
b-d
A-end
b-end
`} />

Slightly larger example:

<Advent day={12} part="a" debug input={`
dc-end
HN-start
start-kj
dc-start
dc-HN
LN-dc
HN-end
kj-sa
kj-HN
kj-dc
`} />

Even larger example:

<Advent day={12} part="a" debug input={`
fs-end
he-DX
fs-he
start-DX
pj-DX
end-zg
zg-sl
zg-pj
pj-he
RW-he
fs-DX
pj-RW
zg-RW
start-pj
he-WI
zg-he
pj-fs
start-RW
`} />

Mine:

<Advent day={12} part="a" debug />

## Day 12b

```typescript
export const d12b = props => {
  const sm = (s: string) => s.charCodeAt(0) >= 97
  const v = {}
  let twice = null
  return d12({
    ...props,
    pre: (node: string) =>
      v[node] && twice
        ? false
        : v[node]
        ? ((twice = node), true)
        : ((v[node] = sm(node)), true),
    post: (node: string) =>
      twice === node ? (twice = null) : (v[node] = false),
  })
}
```

Example:

<Advent day={12} part="b" debug input={`
start-A
start-b
A-c
A-b
b-d
A-end
b-end
`} />

Slightly larger example:

<Advent day={12} part="b" debug input={`
dc-end
HN-start
start-kj
dc-start
dc-HN
LN-dc
HN-end
kj-sa
kj-HN
kj-dc
`} />

Even larger example:

<Advent day={12} part="b" debug input={`
fs-end
he-DX
fs-he
start-DX
pj-DX
end-zg
zg-sl
zg-pj
pj-he
RW-he
fs-DX
pj-RW
zg-RW
start-pj
he-WI
zg-he
pj-fs
start-RW
`} />

Mine:

<Advent day={12} part="b" debug />
